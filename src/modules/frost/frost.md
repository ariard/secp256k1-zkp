Notes on the frost module API
===========================

The following sections contain additional notes on the API of the frost module (`include/secp256k1_frost.h`).
A usage example can be found in `examples/frost.c`.

# API misuse

Users of the frost module must take great care to make sure of the following:

1. Each participant establishes a secure communications channel with each other
   participant and uses that channel to transmit shares and commitments during
   key generation.
2. A unique set of coefficients per key generation session is generated in
   `secp256k1_frost_share_gen`. See the corresponding comment in
   `include/secp256k1_frost.h` for how to ensure that.
3. The `vss_commitments` provided to `secp256k1_frost_share_agg` are sorted by
   the corresponding lexicographic ordering of the x-only pubkey of each
   participant.
4. The `vss_hash` generated by `secp256k1_frost_share_agg` is signed by each
   key generation participant, and those signatures are distributed to each
   participant, and verified by each participant, and the key generation
   session is aborted upon verification failure. Note that fulfilling this step
   removes the need for a broadcast channel.
5. The `pubnonces` provided to `secp256k1_frost_nonce_process` are sorted by
   the corresponding lexicographic ordering of the x-only pubkey of each
   participant, and the `pubkeys` provided to `secp256k1_frost_nonce_process`
   are sorted lexicographically.
6. A unique nonce per signing session is generated in `secp256k1_frost_nonce_gen`.
   See the corresponding comment in `include/secp256k1_frost.h` for how to ensure that.
7. The `secp256k1_frost_secnonce` structure is never copied or serialized.
   See also the comment on `secp256k1_frost_secnonce` in `include/secp256k1_frost.h`.
8. Opaque data structures are never written to or read from directly.
   Instead, only the provided accessor functions are used.
9. If adaptor signatures are used, all partial signatures are verified.

# Key Generation

1. Generate a keypair with `secp256k1_keypair_create` and obtain the x-only
   public key with `secp256k1_keypair_xonly_pub`.
2. For each participant, including oneself, call `secp256k1_frost_share_gen`
   with the x-only public key of that participant, and distribute the share and
   commitments to that participant using a secure channel.
3. After receiving a share and commitment set from each participant, call
   `secp256k1_frost_share_agg` to compute the aggregate share and group public
   key. If this function returns an error, `secp256k1_frost_share_verify` is
   called on each share to determine which participants submitted faulty
   shares.
4. Optionally compute the public verification share by calling
   `secp256k1_frost_compute_pubshare` with the x-only public key of each
   participant. This share is required to verify partial signatures generated
   by `secp256k1_frost_partial_sig_verify`.
5. Sign the `vss_hash` generated by `secp256k1_frost_share_agg` and distribute
   the signature to each participant.
6. Verify the signature received by each participant is a valid signature for
   the `vss_hash` generated by `secp256k1_frost_share_agg`.

# Tweaking


A (Taproot) tweak can be added to the resulting public key with
`secp256k1_xonly_pubkey_tweak_add`, after converting it to an xonly pubkey if
necessary with `secp256k1_xonly_pubkey_from_pubkey`.

An ordinary tweak can be added to the resulting public key with
`secp256k1_ec_pubkey_tweak_add`, after converting it to an ordinary pubkey if
necessary with `secp256k1_frost_pubkey_get`.

Tweaks can also be chained together by tweaking an already tweaked key.

# Signing

1. Generate a keypair with `secp256k1_keypair_create` and obtain the xonly public key with `secp256k1_keypair_xonly_pub`.
2. Optionally add a tweak by calling `secp256k1_frost_pubkey_tweak` and then `secp256k1_frost_pubkey_xonly_tweak_add` for a Taproot tweak and `secp256k1_frost_pubkey_ec_tweak_add` for an ordinary tweak.
3. Generate a pair of secret and public nonce with `secp256k1_frost_nonce_gen` and send the public nonce to the other signers.
4. Process the aggregate nonce with `secp256k1_frost_nonce_process`.
5. Create a partial signature with `secp256k1_frost_partial_sign`.
8. Verify the partial signatures (optional in some scenarios) with `secp256k1_frost_partial_sig_verify`.
9. Someone (not necessarily the signer) obtains all partial signatures and aggregates them into the final Schnorr signature using `secp256k1_frost_partial_sig_agg`.

The aggregate signature can be verified with `secp256k1_schnorrsig_verify`.

Note that steps 1 to 4 can happen before the message to be signed is known to
the signers. Therefore, the communication round to exchange nonces can be
viewed as a pre-processing step that is run whenever convenient to the signers.
This disables some of the defense-in-depth measures that may protect against
API misuse in some cases. Similarly, the API supports an alternative protocol
flow where generating the key (see Key Generation above) is allowed to happen
after exchanging nonces (step 3).

# Verification

A participant who wants to verify the partial signatures, but does not sign itself may do so using the above instructions except that the verifier skips steps 1, 3 and 5.
